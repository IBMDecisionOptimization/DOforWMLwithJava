package com.ibm.ml.mp.others;


import com.ibm.ml.ilog.Credentials;
import com.ibm.ml.ilog.Connector;
import ilog.concert.*;
import ilog.cplex.WmlCplex;
import ilog.cplex.IloCplex;
import ilog.cplex.IloCplex.MultiObjIntInfo;
import ilog.cplex.IloCplex.MultiObjLongInfo;
import ilog.cplex.IloCplex.MultiObjNumInfo;
import com.ibm.ml.mp.helper.InputDataReader;

import java.io.IOException;

public class Diet {

    /**
     *  Print a usage message to stderr and abort.
     */
    static void usage() {
        System.err.println();
        System.err.println("Usage: Diet [options...] <datafile>");
        System.err.println("   By default, the problem will be generated by rows.");
        System.err.println();
        System.err.println("   Supported options are:");
        System.err.println("   -r    generate problem by row");
        System.err.println("   -c    generate problem by column");
        System.err.println("   -i    restrict to integral food quantities (i.e., convert to a MIP)");
        System.err.println("   -m    create a multi-objective problem where, in addition to");
        System.err.println("         minimizing cost, the number of unique foods selected is");
        System.err.println("         maximized (can be combined with -i)");
        System.err.println();
        System.exit(2);
    }

    /**
     * A class to store problem data.
     */
    static class Data {
        int        nFoods;
        int        nNutrs;
        double[]   foodCost;
        double[]   foodMin;
        double[]   foodMax;
        double[]   nutrMin;
        double[]   nutrMax;
        double[][] nutrPerFood;

        Data(String filename) throws IloException, java.io.IOException,
                InputDataReader.InputDataReaderException {
            InputDataReader reader = new InputDataReader(filename);

            foodCost = reader.readDoubleArray();
            foodMin  = reader.readDoubleArray();
            foodMax  = reader.readDoubleArray();
            nutrMin  = reader.readDoubleArray();
            nutrMax  = reader.readDoubleArray();
            nutrPerFood = reader.readDoubleArrayArray();

            nFoods = foodMax.length;
            nNutrs = nutrMax.length;

            if ( nFoods != foodMin.length  ||
                    nFoods != foodMax.length    )
                throw new IloException("inconsistent data in file " + filename);
            if ( nNutrs != nutrMin.length    ||
                    nNutrs != nutrPerFood.length  )
                throw new IloException("inconsistent data in file " + filename);
            for (int i = 0; i < nNutrs; ++i) {
                if ( nutrPerFood[i].length != nFoods )
                    throw new IloException("inconsistent data in file " + filename);
            }
        }
    }

    static void buildModelByRow(IloModeler    model,
                                Data          data,
                                IloNumVar[]   buy,
                                IloObjective  cost,
                                IloNumVarType type) throws IloException {
        int nFoods = data.nFoods;
        int nNutrs = data.nNutrs;

        for (int j = 0; j < nFoods; j++) {
            buy[j] = model.numVar(data.foodMin[j], data.foodMax[j], type);
        }

        cost.setExpr(model.scalProd(data.foodCost, buy));

        for (int i = 0; i < nNutrs; i++) {
            model.addRange(data.nutrMin[i],
                    model.scalProd(data.nutrPerFood[i], buy),
                    data.nutrMax[i]);
        }
    }

    static void buildModelByColumn(IloMPModeler  model,
                                   Data          data,
                                   IloNumVar[]   buy,
                                   IloObjective  cost,
                                   IloNumVarType type) throws IloException {
        int nFoods = data.nFoods;
        int nNutrs = data.nNutrs;

        IloRange[]   constraint = new IloRange[nNutrs];

        for (int i = 0; i < nNutrs; i++) {
            constraint[i] = model.addRange(data.nutrMin[i], data.nutrMax[i]);
        }

        for (int j = 0; j < nFoods; j++) {
            IloColumn col = model.column(cost, data.foodCost[j]);
            for (int i = 0; i < nNutrs; i++) {
                col = col.and(model.column(constraint[i], data.nutrPerFood[i][j]));
            }
            buy[j] = model.numVar(col, data.foodMin[j], data.foodMax[j], type);
        }
    }

    static void createMultiObj(IloCplex cplex,
                               IloNumVar[] buy,
                               IloObjective cost,
                               IloObjective variety) throws IloException {
        // Create binary variables for each food.
        IloNumVar[] varUsed = cplex.numVarArray(buy.length, 0.0, 1.0,
                IloNumVarType.Bool);

        // Add indicator constraints that force the binary variables to 1 if
        // a food is purchased/used.
        for (int i = 0; i < buy.length; ++i) {
            cplex.add(cplex.ifThen(cplex.eq(varUsed[i], 0),
                    cplex.eq(buy[i], 0.0)));
            cplex.add(cplex.ifThen(cplex.eq(buy[i], 0.0),
                    cplex.eq(varUsed[i], 0)));
        }

        // Set up the second objective so that it maximizes the sum of the
        // binary variables.
        variety.setExpr(cplex.sum(varUsed));
        variety.setSense(IloObjectiveSense.Maximize);

        // Create an array of objectives:
        // - the first objective minimizes the cost
        // - the second objective maximizes the variety
        IloNumExpr[] objArray = new IloNumExpr[] {
                cost.getExpr(),
                variety.getExpr()
        };

        // Use a negative weight to maximize the second objective. The
        // objective senses of all objective functions must match. Hence, we
        // have to formulate max(sum) as min(-sum).
        double[] weights = new double[] { 1.0, -1.0 };

        // Adjust priorities such that we optimize the first objective
        // first (i.e., give it a higher priority).
        int[] priorities = new int[] { 2, 1 };

        // Allow a small degradation in the first objective.
        double[] absTols = new double[] { 0.5, 0.0 };
        double[] relTols = new double[] { 0.0, 0.0 };

        // Add the lexicographic objective to the model.
        cplex.add(cplex.minimize(cplex.staticLex(objArray, weights,
                priorities, absTols,
                relTols, "staticLex1")));
    }

    static void printSolutionStat(String what, String val) {
        System.out.printf("    %s: %s%n", what,
                (val != null) ? val : "---");
    }

    static void printMultiObjInfo(IloCplex cplex,
                                  MultiObjIntInfo what,
                                  int subprob)
            throws IloException {
        String valString = null;
        try {
            valString = Integer.toString(cplex.getMultiObjInfo(what, subprob));
        }
        catch (IloException ignore) { }
        printSolutionStat(what.toString(), valString);
    }

    static void printMultiObjInfo(IloCplex cplex,
                                  MultiObjLongInfo what,
                                  int subprob)
            throws IloException {
        String valString = null;
        try {
            valString = Long.toString(cplex.getMultiObjInfo(what, subprob));
        }
        catch (IloException ignore) { }
        printSolutionStat(what.toString(), valString);
    }

    static void printMultiObjInfo(IloCplex cplex,
                                  MultiObjNumInfo what,
                                  int subprob)
            throws IloException {
        String valString = null;
        try {
            valString = Double.toString(cplex.getMultiObjInfo(what, subprob));
        }
        catch (IloException ignore) { }
        printSolutionStat(what.toString(), valString);
    }

    static void printSolutionStats (IloCplex cplex) throws IloException {
        final int num = cplex.getMultiObjNsolves();

        for (int i = 0; i < num; ++i) {
            int prio = cplex.getMultiObjInfo(
                    MultiObjIntInfo.MultiObjPriority, i);
            System.out.printf("subproblem %d [priority %d]:%n", i, prio);
            printMultiObjInfo(cplex, MultiObjIntInfo.MultiObjError, i);
            printMultiObjInfo(cplex, MultiObjIntInfo.MultiObjStatus, i);
            printMultiObjInfo(cplex, MultiObjNumInfo.MultiObjTime, i);
            printMultiObjInfo(cplex, MultiObjNumInfo.MultiObjDetTime, i);
            printMultiObjInfo(cplex, MultiObjLongInfo.MultiObjNiterations, i);
            printMultiObjInfo(cplex, MultiObjNumInfo.MultiObjObjValue, i);
            printMultiObjInfo(cplex, MultiObjNumInfo.MultiObjBestObjValue, i);
            printMultiObjInfo(cplex, MultiObjLongInfo.MultiObjNnodes, i);
            printMultiObjInfo(cplex, MultiObjLongInfo.MultiObjNnodesLeft, i);
        }
    }

    public static void main(String[] args)  {
        try{
        run(args, "cplex_diet.dat", false, false);
        run(args, "cplex_diet.dat", false, true);
        run(args, "cplex_diet.dat", true, true);
        run(args, "cplex_diet.dat", true, false);
        }
        catch (IloException | IOException | InputDataReader.InputDataReaderException e){
            System.out.println("Error: "+e.getMessage());
        }
    }
    private static void run(String[] args, String filename, boolean byColumn, boolean multiobj) throws IloException, IOException, InputDataReader.InputDataReaderException {
        // Set default arguments and parse command line.
        IloNumVarType varType = IloNumVarType.Float;

        for (int i = 0; i < args.length; i++) {
            if ( args[i].charAt(0) == '-') {
                if (args[i].equals("-r"))
                    byColumn = false;
                else if (args[i].equals("-c"))
                    byColumn = true;
                else if (args[i].equals("-i"))
                    varType = IloNumVarType.Int;
                else if (args[i].equals("-m"))
                    multiobj = true;
                else {
                    System.err.printf("Unknown argument: %s%n", args[i]);
                    usage();
                }
            }
            else {
                filename = args[i];
            }
        }

        // Read the data.

        Data data = new Data(filename);
        final int nFoods = data.nFoods;
        //IloCplex cplex = new IloCplex();
        IloCplex cplex = new WmlCplex(
                Credentials.getCredentials("wml.public.conf"),
                Connector.Runtime.DO_12_10,
                Connector.TShirtSize.M,
                1);
        try {
            // Build model
            IloNumVar[] buy = new IloNumVar[nFoods];
            IloObjective cost = cplex.minimize();
            cost.setName("cost");

            if ( byColumn )
                buildModelByColumn(cplex, data, buy, cost, varType);
            else
                buildModelByRow(cplex, data, buy, cost, varType);

            // Optionally, create a second objective.

            IloObjective variety = cplex.maximize();
            variety.setName("number of foods");
            if ( multiobj ) {
                createMultiObj(cplex, buy, cost, variety);
            }
            else {
                cplex.add(cost);
            }

           cplex.setParam(IloCplex.Param.Preprocessing.Presolve, false);
            cplex.setParam(IloCplex.Param.Threads, 2);

            // Solve model

            if ( multiobj ) {
                // Set multi-objective display level to "detailed".
                cplex.setParam(IloCplex.Param.MultiObjective.Display, 2);

                // Purely for demonstrative purposes, set global and local limits
                // using parameter sets.

                // First, set the global deterministic time limit.
                cplex.setParam(IloCplex.Param.DetTimeLimit, 60000);

                // Optimize the multi-objective problem and apply the parameter
                // sets that were created above. The parameter sets are used
                // one-by-one by each optimization.
                if ( !cplex.solve() )
                //if ( !cplex.solve(params) ) Not supported by WML.
                // https://www.ibm.com/support/knowledgecenter/SSSA5P_12.10.0/ilog.odms.cplex.help/refjavacplex/html/ilog/cplex/IloCplex.html#solve(ilog.cplex.IloCplex.ParameterSet[])
                    throw new IloException("Failed to optimize");
            }
            else {
                if ( !cplex.solve() )
                    throw new IloException("Failed to optimize");
            }

            // Print the solution status.

            System.out.println();
            System.out.println("Solution status = " + cplex.getStatus());

            // Print the objective value(s).

            if ( multiobj ) {
                System.out.printf("Solution value 0 (%s) = %f%n",
                        cost.getName(),
                        cplex.getValue(cost.getExpr()));
                System.out.printf("Solution value 1 (%s) = %f%n",
                        variety.getName(),
                        cplex.getValue(variety.getExpr()));
                System.out.println();

                printSolutionStats(cplex);
            }
            else {
                System.out.printf("Solution value = %f%n", cplex.getObjValue());
            }
            System.out.println();

            // Print the solution values.

            for (int i = 0; i < nFoods; i++) {
                System.out.printf("Food %d: Buy = %f%n", i, cplex.getValue(buy[i]));
            }

        }
        finally {
            cplex.end();
        }
    }

}

